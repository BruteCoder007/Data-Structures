#include<stdio.h>
#include<stdio.h>
struct node
{
    int state[3][3];
    int heuristic;
    int depth;
    struct node *parent;
    struct node *poss[4];
};
int a[3][3],i,j,search_i,search_j,goal_state[3][3];
struct node *root,*temp;
int heur_cal(int array[3])
{
    int heur=0,i,j;
    for (i=0;i<5;i++)
    {
        for(j=0;j<3;j++)
        {
            if(goal_state[i][j]!=array[i][j])
               heur++;
        }
    }
    return heur;
}
void get()
{
    int i,j;
    printf("enter the state of the board\n");
    for(i=0;i<3;i++)
    {
        for(j=0;j<3;j++)
            scanf("%d",&a[i][j]);
    }
}
void createspawningtree(struct node *temp)
{
    int i,j,flag=0;
    if(root==NULL)
    { 
        root=nodecreator(a[3]);
        temp=root;
    }
    temp=possibilitiy(root);
    if(temp->poss[0]==NULL&&temp->poss[1]==NULL&&temp->poss[2]==NULL&&temp->poss[3]==NULL)
      return;
    else
    {
        for(i=0;i<4;i++)
            if(temp->poss[i])
                createspawningtree(temp->poss[i])
    }
}
struct node* nodecreator(int a[3])
{
    int i,j;
    struct node *nn=(struct node*)malloc(sizeof(struct node));
     for(i=0;i<3;i++)
            for(j=0;j<3;j++)
                  nn->state[i][j]=a[i][j];               
    nn->parent=NULL;
    nn->poss[0]=nn->poss[1]= nn->poss[2]= nn->poss[3]=NULL;
    return nn;
}
void getposition(int a[][3])
{
      for(i=0;i<3;i++)
      {
         for(j=0;j<3;j++)
         {
             if(a[i][j]==0)
            {
                search_i=i;
                search_j=j;
                return;
            }
         }
      } 
}
struct node* possibility(struct node *nn)
{
    int b[3][3],flag=0;
     getposition(b[3]);
     int t1=search_i;
     int t2=search_j;
     
     for(i=0;i<3;i++)
        for(j=0;j<3;j++)
        {
             
            b[i][j]=nn->state[i][j];
            if(goal_state[i][j]!=nn->state[i][j])
               flag=1;
        }
     if(flag==0)
         return;
     if(t1==1&&t2==1)
     {
        b[1][1]=nn->state[0][1];
        b[0][1]=0;
        nn->poss[0]=nodecreator(b);
        b[0][1]=nn->state[0][1];
        b[1][1]=state[1][0];
        b[1][0]=0;
        nn->poss[1]=nodecreator(b);
        b[1][0]=nn->state[1][0];
        b[1][1]=nn->state[2][1]; 
        b[2][1]=0;
        nn->poss[2]=nodecreator(b);
        b[2][1]=nn->state[2][1];
        b[1][1]=nn->state[1][2];
        b[1][2]=0;
        nn->poss[3]=nodecreator(b);
        b[1][2]=nn->state[1][2];
     } 
     else if(t1==1&&t2==0)
     {
         b[1][0]=nn->state[0][0];
         b[0][0]=0;
         nn->poss[0]=nodecreator(b);
         b[0][0]=nn->state[0][0];
         b[1][0]=nn->state[1][1];
         b[1][1]=0;
         nn->poss[1]=nodecreator(b);
         b[1][1]=nn->state[1]][1];
         b[1][0]=nn->state[2][0];
         b[2][0]=0;
         nn->poss[2]=nodecreator(b);
         b[2][0]=nn->state[2][0];
     }
     else if(t1=1&&t2=2)
     {
         b[1][2]=nn->state[0][2];
         b[0][2]=0;
         nn->poss[0]=nodecreator(b);
         b[0][2]=nn->state[0][2];
         b[1][2]=nn->state[1][1];
         b[1][1]=0;
         nn->poss[1]=nodecreator(b);
         b[1][1]=nn->state[1]][1];
         b[1][2]=nn->state[2][2];
         b[2][2]=0;
         nn->poss[2]=nodecreator(b);
         b[2][2]=nn->state[2][2];
     }
     else if(t1==2&&t2==1)
     {
         b[2][1]=nn->state[2][2];
         b[2][2]=0;
         nn->poss[0]=nodecreator(b);
         b[2][2]=nn->state[2][2];
         b[2][1]=nn->state[1][1];
         b[1][1]=0;
         nn->poss[1]=nodecreator(b);
         b[1][1]=nn->state[1]][1];
         b[2][1]=nn->state[2][0];
         b[2][0]=0;
         nn->poss[2]=nodecreator(b);
         b[2][0]=nn->state[2][0];
     }
     else if(t1==0&&t2==1)
     {
         b[0][1]=nn->state[0][2];
         b[0][2]=0;
         nn->poss[0]=nodecreator(b);
         b[0][2]=nn->state[0][2];
         b[0][1]=nn->state[1][1];
         b[1][1]=0;
         nn->poss[1]=nodecreator(b);
         b[1][1]=nn->state[1]][1];
         b[0][1]=nn->state[0][0];
         b[0][0]=0;
         nn->poss[2]=nodecreator(b);
         b[0][0]=nn->state[0][0];
     }
     else if(t1==0&&t2==0)
     {
         b[0][0]=nn->state[0][1];
         b[0][1]=0;
         nn->poss[0]=nodecreator(b);
         b[0][1]=nn->state[0][1];
         b[0][0]=nn->state[1][0];
         b[1][0]=0;
         nn->poss[1]=nodecreator(b);
         b[1][0]=nn->state[1]][0];
     }
     else if(t1==2&&t2==0)
     {
         b[2][0]=nn->state[2][1];
         b[2][1]=0;
         nn->poss[0]=nodecreator(b);
         b[2][1]=nn->state[2][1];
         b[2][0]=nn->state[1][0];
         b[1][0]=0;
         nn->poss[1]=nodecreator(b);
         b[1][0]=nn->state[1]][0];
     }
     else if(t1==0&&t2==2)
     {
         b[0][2]=nn->state[0][1];
         b[0][1]=0;
         nn->poss[0]=nodecreator(b);
         b[0][1]=nn->state[0][1];
         b[0][2]=nn->state[1][2];
         b[1][2]=0;
         nn->poss[1]=nodecreator(b);
         b[1][2]=nn->state[1]][2]
     }
     else if(t1==2&&t2==2)
     {
         b[2][2]=nn->state[2][1];
         b[2][1]=0;
         nn->poss[0]=nodecreator(b);
         b[2][1]=nn->state[2][1];
         b[2][2]=nn->state[1][2];
         b[1][2]=0;
         nn->poss[1]=nodecreator(b);
         b[1][2]=nn->state[1]][2]
     }
     return nn;
}
void algo(struct node *temp)
{
    int i,j;
    struct node *temp1=NULL,*temp2=NULL;
    temp->depth++;
    if (heur_cal(temp->state)==0)
        return;
    else
    {
        if(temp->poss[0])
            struct node *min=temp->poss[0];
        else if(temp->poss[1]) 
            struct node *min=temp->poss[1];   
        else if(temp->poss[2])
            struct node *min=temp->poss[2];
        else
            struct node *min=temp->poss[3];
        for(i=1;i<4;i++)
        {  
            if(temp->poss[i])
            {
                if(heur_cal(temp->poss[i]->state)+temp->poss[i]->depth<heur_cal(min->state)+temp->poss[i])
                {
                    min=temp->poss[i];
                }
            }
        }
        for(i=0;i<4;i++)
        {
            if(temp->poss[i])
            {
                if(temp->poss[i]!=min && heur_cal(temp->poss[i]->state)==heur_cal(min->state))
                  {
                      temp1=min;
                      temp2=temp->poss[i];
                      algo(temp1);
                      algo(temp2);
                      
                  }
            }
            else
              algo(temp1);
        }
    }
}
void print(struct node *temp)
{
    printf("The state of the board:\n");
    for(i=0;i<3;i++)
    {
        for(j=0;j<3;j++)
        {
            printf("%d\t",temp->state[i][j]);
        }
        printf("\n");
    }
}
int main()
{
    get();
    print(a);
    return 0;
}